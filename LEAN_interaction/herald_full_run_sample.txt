**  Removing old project...
**  Initialising empty Lean project...
âœ“ Lean version verified to be leanprover/lean4:v4.11.0



   ================================================================================
[âœ“] row 0
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Logic.Equiv.Set
   import Mathlib.Order.RelIso.Set
   import Mathlib.Order.WellFounded
   import Mathlib.Order.InitialSeg

   namespace myNameSpace


   open InitialSeg
   variable {Î± : Type*} {Î² : Type*} {Î³ : Type*} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}
     {t : Î³ â†’ Î³ â†’ Prop}
   open Function

   theorem InitialSeg.eq [IsWellOrder Î² s] (f g : r â‰¼i s) (a) : f a = g a := by
     rw [Subsingleton.elim f g]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [Subsingleton.elim f g]",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "Î± : Type u_1 Î² : Type u_2 r : Î± â†’ Î± â†’ Prop s : Î² â†’ Î² â†’ Prop instâœ : IsWellOrder Î² s f g : r â‰¼i s a : Î± âŠ¢ f a = g a",
      "endPos": {"line": 15, "column": 28}}],
    "env": 0}

   âœ” [2/22] Built REPL.Util.Pickle
   âœ” [3/22] Built REPL.Util.Pickle:c.o
   âœ” [4/22] Built REPL.Frontend
   âœ” [5/22] Built REPL.Lean.Environment
   âœ” [6/22] Built REPL.Frontend:c.o
   âœ” [7/22] Built REPL.Lean.Environment:c.o
   âœ” [8/22] Built REPL.JSON
   âœ” [9/22] Built REPL.Util.Path
   âœ” [10/22] Built REPL.Lean.ContextInfo
   âœ” [11/22] Built REPL.Util.Path:c.o
   âœ” [12/22] Built REPL.Lean.ContextInfo:c.o
   âœ” [13/22] Built REPL.Lean.InfoTree
   âœ” [14/22] Built REPL.Snapshots
   âœ” [15/22] Built REPL.JSON:c.o
   âœ” [16/22] Built REPL.Lean.InfoTree:c.o
   âœ” [17/22] Built REPL.Lean.InfoTree.ToJson
   âœ” [18/22] Built REPL.Snapshots:c.o
   âœ” [19/22] Built REPL.Lean.InfoTree.ToJson:c.o
   âœ” [20/22] Built REPL.Main
   âœ” [21/22] Built REPL.Main:c.o
   âœ” [22/22] Built repl
   ----------------------------------------



   ================================================================================
[âœ“] row 1
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Logic.Equiv.Set
   import Mathlib.Order.RelIso.Set
   import Mathlib.Order.WellFounded
   import Mathlib.Order.InitialSeg

   namespace myNameSpace


   open PrincipalSeg
   variable {Î± : Type*} {Î² : Type*} {Î³ : Type*} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}
     {t : Î³ â†’ Î³ â†’ Prop}
   open Function

   theorem PrincipalSeg.top_eq [IsWellOrder Î³ t] (e : r â‰ƒr s) (f : r â‰ºi t) (g : s â‰ºi t) : f.top = g.top := by
     rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]; rfl

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœ : IsWellOrder Î³ t\ne : r â‰ƒr s\nf : r â‰ºi t\ng : s â‰ºi t\nâŠ¢ f.top = g.top",
      "endPos": {"line": 15, "column": 53}},
     {"tactic": "rfl",
      "proofState": 1,
      "pos": {"line": 15, "column": 55},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœ : IsWellOrder Î³ t\ne : r â‰ƒr s\nf : r â‰ºi t\ng : s â‰ºi t\nâŠ¢ (equivLT e g).top = g.top",
      "endPos": {"line": 15, "column": 58}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 2
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.perpBisector_ne_bot : perpBisector pâ‚ pâ‚‚ â‰  âŠ¥ := by
     rw [â† nonempty_iff_ne_bot]; exact perpBisector_nonempty

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [â† nonempty_iff_ne_bot]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ perpBisector pâ‚ pâ‚‚ â‰  âŠ¥",
      "endPos": {"line": 17, "column": 28}},
     {"tactic": "exact perpBisector_nonempty",
      "proofState": 1,
      "pos": {"line": 17, "column": 30},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ (â†‘(perpBisector pâ‚ pâ‚‚)).Nonempty",
      "endPos": {"line": 17, "column": 57}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 17, "column": 57},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.perpBisector_ne_bot':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 3
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Functor.KanExtension.Basic
   import Mathlib.CategoryTheory.Functor.KanExtension.Pointwise

   namespace myNameSpace


   open CategoryTheory
   open Functor
   open LeftExtension
   open IsPointwiseLeftKanExtensionAt
   open Category Limits
   variable {C D H : Type*} [Category C] [Category D] [Category H] (L : C â¥¤ D) (F : C â¥¤ H)
   variable {F L}
   variable (E : LeftExtension L F)
   variable (E : LeftExtension L F)
   variable (L F) in
   /-- The cocones for `CostructuredArrow.proj L Y â‹™ F`, as a functor from `LeftExtension L F`. -/
   @[simps]
   def coconeAtFunctor (Y : D) :
       LeftExtension L F â¥¤ Cocone (CostructuredArrow.proj L Y â‹™ F) where
     obj E := E.coconeAt Y
     map {E E'} Ï† := CoconeMorphism.mk (Ï†.right.app Y) (fun G => by
       dsimp
       rw [â† StructuredArrow.w Ï†]
       simp)
   variable {E} in
   lemma IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt
       {Y : D} (h : E.IsPointwiseLeftKanExtensionAt Y) :
       HasPointwiseLeftKanExtensionAt L F Y := âŸ¨_, hâŸ©

   theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app 
       {X : C} (h : E.IsPointwiseLeftKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :
       IsIso (E.hom.app X) := by
     simpa using h.isIso_Î¹_app_of_isTerminal _ CostructuredArrow.mkIdTerminal

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "dsimp",
      "proofState": 0,
      "pos": {"line": 23, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ ((fun E => E.coconeAt Y) E).Î¹.app G â‰« Ï†.right.app Y = ((fun E => E.coconeAt Y) E').Î¹.app G",
      "endPos": {"line": 23, "column": 9}},
     {"tactic": "rw [â† StructuredArrow.w Ï†]",
      "proofState": 1,
      "pos": {"line": 24, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ (E.hom.app G.left â‰« E.right.map G.hom) â‰« Ï†.right.app Y = E'.hom.app G.left â‰« E'.right.map G.hom",
      "endPos": {"line": 24, "column": 30}},
     {"tactic": "simp",
      "proofState": 2,
      "pos": {"line": 25, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ (E.hom.app G.left â‰« E.right.map G.hom) â‰« Ï†.right.app Y =\n    (E.hom â‰« ((whiskeringLeft C D H).obj L).map Ï†.right).app G.left â‰« E'.right.map G.hom",
      "endPos": {"line": 25, "column": 8}},
     {"tactic":
      "simpa using h.isIso_Î¹_app_of_isTerminal _ CostructuredArrow.mkIdTerminal",
      "proofState": 3,
      "pos": {"line": 34, "column": 2},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœâ´ : Category.{u_4, u_1} C\ninstâœÂ³ : Category.{u_5, u_2} D\ninstâœÂ² : Category.{u_6, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nX : C\nh : E.IsPointwiseLeftKanExtensionAt (L.obj X)\ninstâœÂ¹ : L.Full\ninstâœ : L.Faithful\nâŠ¢ IsIso (E.hom.app X)",
      "endPos": {"line": 34, "column": 74}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 4
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Logic.Equiv.Set
   import Mathlib.Order.RelIso.Set
   import Mathlib.Order.WellFounded
   import Mathlib.Order.InitialSeg

   namespace myNameSpace


   open PrincipalSeg
   variable {Î± : Type*} {Î² : Type*} {Î³ : Type*} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}
     {t : Î³ â†’ Î³ â†’ Prop}
   open Function

   theorem PrincipalSeg.topLTTop {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î³ t]
       (f : PrincipalSeg r s) (g : PrincipalSeg s t) (h : PrincipalSeg r t) : t h.top g.top := by
     rw [Subsingleton.elim h (f.trans g)]
     apply PrincipalSeg.lt_top

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [Subsingleton.elim h (f.trans g)]",
      "proofState": 0,
      "pos": {"line": 16, "column": 2},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœ : IsWellOrder Î³ t\nf : r â‰ºi s\ng : s â‰ºi t\nh : r â‰ºi t\nâŠ¢ t h.top g.top",
      "endPos": {"line": 16, "column": 38}},
     {"tactic": "apply PrincipalSeg.lt_top",
      "proofState": 1,
      "pos": {"line": 17, "column": 2},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœ : IsWellOrder Î³ t\nf : r â‰ºi s\ng : s â‰ºi t\nh : r â‰ºi t\nâŠ¢ t (f.trans g).top g.top",
      "endPos": {"line": 17, "column": 27}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 5
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Symmetric
   import Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts
   import Mathlib.CategoryTheory.ChosenFiniteProducts

   namespace myNameSpace


   open CategoryTheory
   open ChosenFiniteProducts
   variable {C : Type u} [Category.{v} C] [ChosenFiniteProducts C]
   open MonoidalCategory

   theorem CategoryTheory.ChosenFiniteProducts.lift_fst {T X Y : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) : lift f g â‰« fst _ _ = f := by
     simp [lift, fst]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [lift, fst]",
      "proofState": 0,
      "pos": {"line": 14, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nT X Y : C\nf : T âŸ¶ X\ng : T âŸ¶ Y\nâŠ¢ lift f g â‰« fst X Y = f",
      "endPos": {"line": 14, "column": 18}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 6
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.mem_perpBisector_iff_dist_eq' : c âˆˆ perpBisector pâ‚ pâ‚‚ â†” dist pâ‚ c = dist pâ‚‚ c := by
     simp only [mem_perpBisector_iff_dist_eq, dist_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp only [mem_perpBisector_iff_dist_eq, dist_comm]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\nc pâ‚ pâ‚‚ : P\nâŠ¢ c âˆˆ perpBisector pâ‚ pâ‚‚ â†” dist pâ‚ c = dist pâ‚‚ c",
      "endPos": {"line": 17, "column": 53}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 17, "column": 53},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.mem_perpBisector_iff_dist_eq'':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 7
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.right_mem_perpBisector : pâ‚‚ âˆˆ perpBisector pâ‚ pâ‚‚ â†” pâ‚ = pâ‚‚ := by
     simpa [mem_perpBisector_iff_inner_eq_inner] using eq_comm

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa [mem_perpBisector_iff_inner_eq_inner] using eq_comm",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ pâ‚‚ âˆˆ perpBisector pâ‚ pâ‚‚ â†” pâ‚ = pâ‚‚",
      "endPos": {"line": 17, "column": 59}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 17, "column": 2},
      "endPos": {"line": 17, "column": 59},
      "data":
      "try 'simp' instead of 'simpa'\nnote: this linter can be disabled with `set_option linter.unnecessarySimpa false`"},
     {"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 17, "column": 59},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.right_mem_perpBisector':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 8
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Symmetric
   import Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts
   import Mathlib.CategoryTheory.ChosenFiniteProducts

   namespace myNameSpace


   open CategoryTheory
   open ChosenFiniteProducts
   variable {C : Type u} [Category.{v} C] [ChosenFiniteProducts C]
   open MonoidalCategory

   theorem CategoryTheory.ChosenFiniteProducts.lift_snd {T X Y : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) : lift f g â‰« snd _ _ = g := by
     simp [lift, snd]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [lift, snd]",
      "proofState": 0,
      "pos": {"line": 14, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nT X Y : C\nf : T âŸ¶ X\ng : T âŸ¶ Y\nâŠ¢ lift f g â‰« snd X Y = g",
      "endPos": {"line": 14, "column": 18}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 9
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_id : YonedaCollection.mapâ‚ (ğŸ™ F) (X := X) = id := by
     aesop_cat

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "aesop_cat",
      "proofState": 0,
      "pos": {"line": 16, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nâŠ¢ mapâ‚ (ğŸ™ F) = id",
      "endPos": {"line": 16, "column": 11}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 10
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Functor.KanExtension.Basic
   import Mathlib.CategoryTheory.Functor.KanExtension.Pointwise

   namespace myNameSpace


   open CategoryTheory
   open Functor
   open LeftExtension
   open IsPointwiseLeftKanExtension
   open Category Limits
   variable {C D H : Type*} [Category C] [Category D] [Category H] (L : C â¥¤ D) (F : C â¥¤ H)
   variable {F L}
   variable (E : LeftExtension L F)
   variable (E : LeftExtension L F)
   variable (L F) in
   /-- The cocones for `CostructuredArrow.proj L Y â‹™ F`, as a functor from `LeftExtension L F`. -/
   @[simps]
   def coconeAtFunctor (Y : D) :
       LeftExtension L F â¥¤ Cocone (CostructuredArrow.proj L Y â‹™ F) where
     obj E := E.coconeAt Y
     map {E E'} Ï† := CoconeMorphism.mk (Ï†.right.app Y) (fun G => by
       dsimp
       rw [â† StructuredArrow.w Ï†]
       simp)
   variable {E} in
   lemma IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt
       {Y : D} (h : E.IsPointwiseLeftKanExtensionAt Y) :
       HasPointwiseLeftKanExtensionAt L F Y := âŸ¨_, hâŸ©
   variable {E E'}
   variable (h : E.IsPointwiseLeftKanExtension)
   include h

   theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext 
       {G : LeftExtension L F} {fâ‚ fâ‚‚ : E âŸ¶ G} : fâ‚ = fâ‚‚ := by
     ext Y
     apply (h Y).hom_ext
     intro X
     have eqâ‚ := congr_app (StructuredArrow.w fâ‚) X.left
     have eqâ‚‚ := congr_app (StructuredArrow.w fâ‚‚) X.left
     dsimp at eqâ‚ eqâ‚‚ âŠ¢
     simp only [assoc, NatTrans.naturality]
     rw [reassoc_of% eqâ‚, reassoc_of% eqâ‚‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "dsimp",
      "proofState": 0,
      "pos": {"line": 23, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ ((fun E => E.coconeAt Y) E).Î¹.app G â‰« Ï†.right.app Y = ((fun E => E.coconeAt Y) E').Î¹.app G",
      "endPos": {"line": 23, "column": 9}},
     {"tactic": "rw [â† StructuredArrow.w Ï†]",
      "proofState": 1,
      "pos": {"line": 24, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ (E.hom.app G.left â‰« E.right.map G.hom) â‰« Ï†.right.app Y = E'.hom.app G.left â‰« E'.right.map G.hom",
      "endPos": {"line": 24, "column": 30}},
     {"tactic": "simp",
      "proofState": 2,
      "pos": {"line": 25, "column": 4},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{?u.2125, u_1} C\ninstâœÂ¹ : Category.{?u.2129, u_2} D\ninstâœ : Category.{?u.2133, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nEâœÂ¹ Eâœ : L.LeftExtension F\nY : D\nE E' : L.LeftExtension F\nÏ† : E âŸ¶ E'\nG : CostructuredArrow L Y\nâŠ¢ (E.hom.app G.left â‰« E.right.map G.hom) â‰« Ï†.right.app Y =\n    (E.hom â‰« ((whiskeringLeft C D H).obj L).map Ï†.right).app G.left â‰« E'.right.map G.hom",
      "endPos": {"line": 25, "column": 8}},
     {"tactic": "ext Y",
      "proofState": 3,
      "pos": {"line": 36, "column": 2},
      "goals":
      "C : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nâŠ¢ fâ‚ = fâ‚‚",
      "endPos": {"line": 36, "column": 7}},
     {"tactic": "apply (h Y).hom_ext",
      "proofState": 4,
      "pos": {"line": 37, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nâŠ¢ fâ‚.right.app Y = fâ‚‚.right.app Y",
      "endPos": {"line": 37, "column": 21}},
     {"tactic": "intro X",
      "proofState": 5,
      "pos": {"line": 38, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nâŠ¢ âˆ€ (j : CostructuredArrow L Y), (E.coconeAt Y).Î¹.app j â‰« fâ‚.right.app Y = (E.coconeAt Y).Î¹.app j â‰« fâ‚‚.right.app Y",
      "endPos": {"line": 38, "column": 9}},
     {"tactic": "have eqâ‚ := congr_app (StructuredArrow.w fâ‚) X.left",
      "proofState": 6,
      "pos": {"line": 39, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nX : CostructuredArrow L Y\nâŠ¢ (E.coconeAt Y).Î¹.app X â‰« fâ‚.right.app Y = (E.coconeAt Y).Î¹.app X â‰« fâ‚‚.right.app Y",
      "endPos": {"line": 39, "column": 53}},
     {"tactic": "have eqâ‚‚ := congr_app (StructuredArrow.w fâ‚‚) X.left",
      "proofState": 7,
      "pos": {"line": 40, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nX : CostructuredArrow L Y\neqâ‚ : (E.hom â‰« ((whiskeringLeft C D H).obj L).map fâ‚.right).app X.left = G.hom.app X.left\nâŠ¢ (E.coconeAt Y).Î¹.app X â‰« fâ‚.right.app Y = (E.coconeAt Y).Î¹.app X â‰« fâ‚‚.right.app Y",
      "endPos": {"line": 40, "column": 53}},
     {"tactic": "dsimp at eqâ‚ eqâ‚‚ âŠ¢",
      "proofState": 8,
      "pos": {"line": 41, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nX : CostructuredArrow L Y\neqâ‚ : (E.hom â‰« ((whiskeringLeft C D H).obj L).map fâ‚.right).app X.left = G.hom.app X.left\neqâ‚‚ : (E.hom â‰« ((whiskeringLeft C D H).obj L).map fâ‚‚.right).app X.left = G.hom.app X.left\nâŠ¢ (E.coconeAt Y).Î¹.app X â‰« fâ‚.right.app Y = (E.coconeAt Y).Î¹.app X â‰« fâ‚‚.right.app Y",
      "endPos": {"line": 41, "column": 20}},
     {"tactic": "simp only [assoc, NatTrans.naturality]",
      "proofState": 9,
      "pos": {"line": 42, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nX : CostructuredArrow L Y\neqâ‚ : E.hom.app X.left â‰« fâ‚.right.app (L.obj X.left) = G.hom.app X.left\neqâ‚‚ : E.hom.app X.left â‰« fâ‚‚.right.app (L.obj X.left) = G.hom.app X.left\nâŠ¢ (E.hom.app X.left â‰« E.right.map X.hom) â‰« fâ‚.right.app Y = (E.hom.app X.left â‰« E.right.map X.hom) â‰« fâ‚‚.right.app Y",
      "endPos": {"line": 42, "column": 40}},
     {"tactic": "rw [reassoc_of% eqâ‚, reassoc_of% eqâ‚‚]",
      "proofState": 10,
      "pos": {"line": 43, "column": 2},
      "goals":
      "case h.w.h\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninstâœÂ² : Category.{u_4, u_1} C\ninstâœÂ¹ : Category.{u_6, u_2} D\ninstâœ : Category.{u_5, u_3} H\nL : C â¥¤ D\nF : C â¥¤ H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nfâ‚ fâ‚‚ : E âŸ¶ G\nY : D\nX : CostructuredArrow L Y\neqâ‚ : E.hom.app X.left â‰« fâ‚.right.app (L.obj X.left) = G.hom.app X.left\neqâ‚‚ : E.hom.app X.left â‰« fâ‚‚.right.app (L.obj X.left) = G.hom.app X.left\nâŠ¢ E.hom.app X.left â‰« fâ‚.right.app (L.obj X.left) â‰« G.right.map X.hom =\n    E.hom.app X.left â‰« fâ‚‚.right.app (L.obj X.left) â‰« G.right.map X.hom",
      "endPos": {"line": 43, "column": 39}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 11
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.counitForward_val_fst (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :
       (counitForward F s x).val.fst = s.hom := by
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\ns : CostructuredArrow yoneda A\nx : F.obj (op s)\nâŠ¢ YonedaCollection.fst (counitForward F s x).val = s.hom",
      "endPos": {"line": 17, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 12
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isIso_hom_app 
       {X : C} (h : E.IsPointwiseRightKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :
       IsIso (E.hom.app X) := by
     simpa using h.isIso_Ï€_app_of_isInitial _ StructuredArrow.mkIdInitial

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:17: unknown identifier 'E.IsPointwiseRightKanExtensionAt'
     error: ././././TmpProjDir/Basic.lean:7:62: unknown identifier 'L.Full'
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 13
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.AlgebraicGeometry.Morphisms.Basic
   import Mathlib.RingTheory.RingHomProperties
   import Mathlib.AlgebraicGeometry.Morphisms.Constructors

   namespace myNameSpace


   open AlgebraicGeometry
   open TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite
   variable (P : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (_ : Î± â†’ Î²), Prop)

   theorem AlgebraicGeometry.topologically_iso_le 
       (hP : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P f) :
       MorphismProperty.isomorphisms Scheme â‰¤ (topologically P) := by
     intro X Y e (he : IsIso e)
     have : IsIso e := he
     exact hP (TopCat.homeoOfIso (asIso e.val.base))

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "intro X Y e (he : IsIso e)",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhP : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P â‡‘f\nâŠ¢ MorphismProperty.isomorphisms Scheme â‰¤ topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P",
      "endPos": {"line": 15, "column": 28}},
     {"tactic": "have : IsIso e := he",
      "proofState": 1,
      "pos": {"line": 16, "column": 2},
      "goals":
      "P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhP : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P â‡‘f\nX Y : Scheme\ne : X âŸ¶ Y\nhe : IsIso e\nâŠ¢ topologically (fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P) e",
      "endPos": {"line": 16, "column": 22}},
     {"tactic": "exact hP (TopCat.homeoOfIso (asIso e.val.base))",
      "proofState": 2,
      "pos": {"line": 17, "column": 2},
      "goals":
      "P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhP : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P â‡‘f\nX Y : Scheme\ne : X âŸ¶ Y\nhe this : IsIso e\nâŠ¢ topologically (fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P) e",
      "endPos": {"line": 17, "column": 49}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 14
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚‚_id : YonedaCollection.mapâ‚‚ F (ğŸ™ X) = id := by
     ext; all_goals simp

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:91: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 15
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.midpoint_mem_perpBisector (pâ‚ pâ‚‚ : P) :
       midpoint â„ pâ‚ pâ‚‚ âˆˆ perpBisector pâ‚ pâ‚‚ := by
     simp [mem_perpBisector_iff_inner_eq_zero]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [mem_perpBisector_iff_inner_eq_zero]",
      "proofState": 0,
      "pos": {"line": 18, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ midpoint â„ pâ‚ pâ‚‚ âˆˆ perpBisector pâ‚ pâ‚‚",
      "endPos": {"line": 18, "column": 43}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 18, "column": 43},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.midpoint_mem_perpBisector':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 16
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.app_unitForward {F : Cáµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ A) (X : Cáµ’áµ–)
       (p : YonedaCollection (restrictedYonedaObj Î·) X.unop) :
       Î·.app X (unitForward Î· X.unop p) = p.yonedaEquivFst := by
     simpa [unitForward] using p.snd.app_val

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa [unitForward] using p.snd.app_val",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA F : Cáµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ A\nX : Cáµ’áµ–\np : YonedaCollection (restrictedYonedaObj Î·) (unop X)\nâŠ¢ Î·.app X (unitForward Î· (unop X) p) = p.yonedaEquivFst",
      "endPos": {"line": 17, "column": 41}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 17
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.unitForward_naturalityâ‚‚ {F : Cáµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ A) (X Y : C) (f : X âŸ¶ Y)
       (p : YonedaCollection (restrictedYonedaObj Î·) Y) :
       unitForward Î· X (YonedaCollection.mapâ‚‚ (restrictedYonedaObj Î·) f p) =
         F.map f.op (unitForward Î· Y p) := by
     simp [unitForward]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [unitForward]",
      "proofState": 0,
      "pos": {"line": 18, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA F : Cáµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ A\nX Y : C\nf : X âŸ¶ Y\np : YonedaCollection (restrictedYonedaObj Î·) Y\nâŠ¢ unitForward Î· X (YonedaCollection.mapâ‚‚ (restrictedYonedaObj Î·) f p) = F.map f.op (unitForward Î· Y p)",
      "endPos": {"line": 18, "column": 20}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 18
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Symmetric
   import Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts
   import Mathlib.CategoryTheory.ChosenFiniteProducts

   namespace myNameSpace


   open CategoryTheory
   open ChosenFiniteProducts
   variable {C : Type u} [Category.{v} C] [ChosenFiniteProducts C]
   open MonoidalCategory

   theorem CategoryTheory.ChosenFiniteProducts.associator_inv_fst (X Y Z : C) :
       (Î±_ X Y Z).inv â‰« fst _ _ â‰« fst _ _ = fst _ _ := by
     erw [lift_fst_assoc, lift_fst]
     rfl

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "erw [lift_fst_assoc, lift_fst]",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nX Y Z : C\nâŠ¢ (Î±_ X Y Z).inv â‰« fst (X âŠ— Y) Z â‰« fst X Y = fst X (Y âŠ— Z)",
      "endPos": {"line": 15, "column": 32}},
     {"tactic": "rfl",
      "proofState": 1,
      "pos": {"line": 16, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nX Y Z : C\nâŠ¢ Limits.BinaryFan.fst (product X (product Y Z).cone.pt).cone = fst X (Y âŠ— Z)",
      "endPos": {"line": 16, "column": 5}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 19
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_yonedaEquivFst {G : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ G)
       (p : YonedaCollection F X) :
       (YonedaCollection.mapâ‚ Î· p).yonedaEquivFst = p.yonedaEquivFst := by
     simp only [YonedaCollection.yonedaEquivFst_eq, mapâ‚_fst]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp only [YonedaCollection.yonedaEquivFst_eq, mapâ‚_fst]",
      "proofState": 0,
      "pos": {"line": 18, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nG : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ G\np : YonedaCollection F X\nâŠ¢ (mapâ‚ Î· p).yonedaEquivFst = p.yonedaEquivFst",
      "endPos": {"line": 18, "column": 58}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 20
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚‚_fst {Y : C} (f : X âŸ¶ Y) (p : YonedaCollection F Y) :
       (YonedaCollection.mapâ‚‚ F f p).fst = yoneda.map f â‰« p.fst := by
     simp [mapâ‚‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [mapâ‚‚]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\np : YonedaCollection F Y\nâŠ¢ (mapâ‚‚ F f p).fst = yoneda.map f â‰« p.fst",
      "endPos": {"line": 17, "column": 13}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 21
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚‚_snd {Y : C} (f : X âŸ¶ Y) (p : YonedaCollection F Y) :
       (YonedaCollection.mapâ‚‚ F f p).snd = F.map ((CostructuredArrow.mkPrecomp p.fst f).op â‰«
         eqToHom (by rw [YonedaCollection.mapâ‚‚_fst f])) p.snd := by
     simp [mapâ‚‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [YonedaCollection.mapâ‚‚_fst f]",
      "proofState": 0,
      "pos": {"line": 17, "column": 18},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\np : YonedaCollection F Y\nâŠ¢ op (CostructuredArrow.mk (yoneda.map f â‰« p.fst)) = op (CostructuredArrow.mk (mapâ‚‚ F f p).fst)",
      "endPos": {"line": 17, "column": 50}},
     {"tactic": "simp [mapâ‚‚]",
      "proofState": 1,
      "pos": {"line": 18, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\np : YonedaCollection F Y\nâŠ¢ (mapâ‚‚ F f p).snd = F.map ((CostructuredArrow.mkPrecomp p.fst f).op â‰« eqToHom â‹¯) p.snd",
      "endPos": {"line": 18, "column": 13}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 22
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Symmetric
   import Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts
   import Mathlib.CategoryTheory.ChosenFiniteProducts

   namespace myNameSpace


   open CategoryTheory
   open ChosenFiniteProducts
   variable {C : Type u} [Category.{v} C] [ChosenFiniteProducts C]
   open MonoidalCategory

   theorem CategoryTheory.ChosenFiniteProducts.associator_hom_snd_fst (X Y Z : C) :
       (Î±_ X Y Z).hom â‰« snd _ _ â‰« fst _ _ = fst _ _ â‰« snd _ _ := by
     erw [lift_snd_assoc, lift_fst]
     rfl

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "erw [lift_snd_assoc, lift_fst]",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nX Y Z : C\nâŠ¢ (Î±_ X Y Z).hom â‰« snd X (Y âŠ— Z) â‰« fst Y Z = fst (X âŠ— Y) Z â‰« snd X Y",
      "endPos": {"line": 15, "column": 32}},
     {"tactic": "rfl",
      "proofState": 1,
      "pos": {"line": 16, "column": 2},
      "goals":
      "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : ChosenFiniteProducts C\nX Y Z : C\nâŠ¢ Limits.BinaryFan.fst (product (product X Y).cone.pt Z).cone â‰« Limits.BinaryFan.snd (product X Y).cone =\n    fst (X âŠ— Y) Z â‰« snd X Y",
      "endPos": {"line": 16, "column": 5}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 23
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Logic.Equiv.Set
   import Mathlib.Order.RelIso.Set
   import Mathlib.Order.WellFounded
   import Mathlib.Order.InitialSeg

   namespace myNameSpace


   open InitialSeg
   variable {Î± : Type*} {Î² : Type*} {Î³ : Type*} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}
     {t : Î³ â†’ Î³ â†’ Prop}
   open Function

   theorem InitialSeg.leLT_apply [IsWellOrder Î² s] [IsTrans Î³ t] (f : r â‰¼i s) (g : s â‰ºi t) (a : Î±) :
       (f.leLT g) a = g (f a) := by
     delta InitialSeg.leLT; cases' f.ltOrEq with f' f'
     Â· simp only [PrincipalSeg.trans_apply, f.ltOrEq_apply_left]
     Â· simp only [PrincipalSeg.equivLT_apply, f.ltOrEq_apply_right]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "delta InitialSeg.leLT",
      "proofState": 0,
      "pos": {"line": 16, "column": 2},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœÂ¹ : IsWellOrder Î² s\ninstâœ : IsTrans Î³ t\nf : r â‰¼i s\ng : s â‰ºi t\na : Î±\nâŠ¢ (f.leLT g).toRelEmbedding a = g.toRelEmbedding (f a)",
      "endPos": {"line": 16, "column": 23}},
     {"tactic": "cases' f.ltOrEq with f' f'",
      "proofState": 1,
      "pos": {"line": 16, "column": 25},
      "goals":
      "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœÂ¹ : IsWellOrder Î² s\ninstâœ : IsTrans Î³ t\nf : r â‰¼i s\ng : s â‰ºi t\na : Î±\nâŠ¢ (match f.ltOrEq with\n        | Sum.inl f' => f'.trans g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)",
      "endPos": {"line": 16, "column": 51}},
     {"tactic": "simp only [PrincipalSeg.trans_apply, f.ltOrEq_apply_left]",
      "proofState": 2,
      "pos": {"line": 17, "column": 4},
      "goals":
      "case inl\nÎ± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœÂ¹ : IsWellOrder Î² s\ninstâœ : IsTrans Î³ t\nf : r â‰¼i s\ng : s â‰ºi t\na : Î±\nf' : r â‰ºi s\nâŠ¢ (match Sum.inl f' with\n        | Sum.inl f' => f'.trans g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)",
      "endPos": {"line": 17, "column": 61}},
     {"tactic": "simp only [PrincipalSeg.equivLT_apply, f.ltOrEq_apply_right]",
      "proofState": 3,
      "pos": {"line": 18, "column": 4},
      "goals":
      "case inr\nÎ± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\ninstâœÂ¹ : IsWellOrder Î² s\ninstâœ : IsTrans Î³ t\nf : r â‰¼i s\ng : s â‰ºi t\na : Î±\nf' : r â‰ƒr s\nâŠ¢ (match Sum.inr f' with\n        | Sum.inl f' => f'.trans g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)",
      "endPos": {"line": 18, "column": 64}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 24
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Logic.Equiv.Set
   import Mathlib.Order.RelIso.Set
   import Mathlib.Order.WellFounded
   import Mathlib.Order.InitialSeg

   namespace myNameSpace


   open PrincipalSeg
   variable {Î± : Type*} {Î² : Type*} {Î³ : Type*} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}
     {t : Î³ â†’ Î³ â†’ Prop}
   open Function

   theorem PrincipalSeg.irrefl {r : Î± â†’ Î± â†’ Prop} [IsWellOrder Î± r] (f : r â‰ºi r) : False := by
     have h := f.lt_top f.top
     rw [show f f.top = f.top from InitialSeg.eq (â†‘f) (InitialSeg.refl r) f.top] at h
     exact _root_.irrefl _ h

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "have h := f.lt_top f.top",
      "proofState": 0,
      "pos": {"line": 15, "column": 2},
      "goals":
      "Î± : Type u_1 r : Î± â†’ Î± â†’ Prop instâœ : IsWellOrder Î± r f : r â‰ºi r âŠ¢ False",
      "endPos": {"line": 15, "column": 26}},
     {"tactic":
      "rw [show f f.top = f.top from InitialSeg.eq (â†‘f) (InitialSeg.refl r) f.top] at h",
      "proofState": 1,
      "pos": {"line": 16, "column": 2},
      "goals":
      "Î± : Type u_1 r : Î± â†’ Î± â†’ Prop instâœ : IsWellOrder Î± r f : r â‰ºi r h : r (f.toRelEmbedding f.top) f.top âŠ¢ False",
      "endPos": {"line": 16, "column": 82}},
     {"tactic": "exact _root_.irrefl _ h",
      "proofState": 2,
      "pos": {"line": 17, "column": 2},
      "goals":
      "Î± : Type u_1 r : Î± â†’ Î± â†’ Prop instâœ : IsWellOrder Î± r f : r â‰ºi r h : r f.top f.top âŠ¢ False",
      "endPos": {"line": 17, "column": 25}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 25
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.GroupTheory.FreeGroup.Basic
   import Mathlib.GroupTheory.FreeGroup.IsFreeGroup

   namespace myNameSpace


   open FreeGroupBasis
   open Function Set
   variable {Î¹ Î¹' G H : Type*} [Group G] [Group H]

   theorem FreeGroupBasis.repr_apply_coe (b : FreeGroupBasis Î¹ G) (i : Î¹) : b.repr (b i) = FreeGroup.of i := by
     change b.repr (b.repr.symm (FreeGroup.of i)) = FreeGroup.of i
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "change b.repr (b.repr.symm (FreeGroup.of i)) = FreeGroup.of i",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals":
      "Î¹ : Type u_1 G : Type u_3 instâœ : Group G b : FreeGroupBasis Î¹ G i : Î¹ âŠ¢ b.repr (b i) = FreeGroup.of i",
      "endPos": {"line": 12, "column": 63}},
     {"tactic": "simp",
      "proofState": 1,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î¹ : Type u_1\nG : Type u_3\ninstâœ : Group G\nb : FreeGroupBasis Î¹ G\ni : Î¹\nâŠ¢ b.repr (b.repr.symm (FreeGroup.of i)) = FreeGroup.of i",
      "endPos": {"line": 13, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 26
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.left_mem_perpBisector : pâ‚ âˆˆ perpBisector pâ‚ pâ‚‚ â†” pâ‚ = pâ‚‚ := by
     rw [perpBisector_comm, right_mem_perpBisector, eq_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [perpBisector_comm, right_mem_perpBisector, eq_comm]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ pâ‚ âˆˆ perpBisector pâ‚ pâ‚‚ â†” pâ‚ = pâ‚‚",
      "endPos": {"line": 17, "column": 57}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 17, "column": 57},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.left_mem_perpBisector':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 27
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_zero' (Î¼ : Measure Î±) : Î¼.tilted 0 = (Î¼ Set.univ)â»Â¹ â€¢ Î¼ := by
     change Î¼.tilted (fun _ â†¦ 0) = (Î¼ Set.univ)â»Â¹ â€¢ Î¼
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "change Î¼.tilted (fun _ â†¦ 0) = (Î¼ Set.univ)â»Â¹ â€¢ Î¼",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± âŠ¢ Î¼.tilted 0 = (Î¼ Set.univ)â»Â¹ â€¢ Î¼",
      "endPos": {"line": 13, "column": 50}},
     {"tactic": "simp",
      "proofState": 1,
      "pos": {"line": 14, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± âŠ¢ (Î¼.tilted fun x => 0) = (Î¼ Set.univ)â»Â¹ â€¢ Î¼",
      "endPos": {"line": 14, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 28
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_apply' (Î¼ : Measure Î±) (f : Î± â†’ â„) {s : Set Î±} (hs : MeasurableSet s) :
       Î¼.tilted f s = âˆ«â» a in s, ENNReal.ofReal (exp (f a) / âˆ« x, exp (f x) âˆ‚Î¼) âˆ‚Î¼ := by
     rw [Measure.tilted, withDensity_apply _ hs]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [Measure.tilted, withDensity_apply _ hs]",
      "proofState": 0,
      "pos": {"line": 14, "column": 2},
      "goals":
      "Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ : Measure Î±\nf : Î± â†’ â„\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ (Î¼.tilted f) s = âˆ«â» (a : Î±) in s, ENNReal.ofReal (rexp (f a) / âˆ« (x : Î±), rexp (f x) âˆ‚Î¼) âˆ‚Î¼",
      "endPos": {"line": 14, "column": 45}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 29
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open AffineSubspace
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}

   theorem AffineSubspace.perpBisector_comm (pâ‚ pâ‚‚ : P) : perpBisector pâ‚ pâ‚‚ = perpBisector pâ‚‚ pâ‚ := by
     ext c; simp only [mem_perpBisector_iff_dist_eq, eq_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "ext c",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ : P\nâŠ¢ perpBisector pâ‚ pâ‚‚ = perpBisector pâ‚‚ pâ‚",
      "endPos": {"line": 17, "column": 7}},
     {"tactic": "simp only [mem_perpBisector_iff_dist_eq, eq_comm]",
      "proofState": 1,
      "pos": {"line": 17, "column": 9},
      "goals":
      "case h\nV : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ instâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ c : P\nâŠ¢ c âˆˆ perpBisector pâ‚ pâ‚‚ â†” c âˆˆ perpBisector pâ‚‚ pâ‚",
      "endPos": {"line": 17, "column": 58}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 16, "column": 0},
      "endPos": {"line": 17, "column": 58},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.AffineSubspace.perpBisector_comm':\n  [NormedAddTorsor V P]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 30
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Analysis.InnerProductSpace.Orthogonal
   import Mathlib.Analysis.Normed.Group.AddTorsor
   import Mathlib.Geometry.Euclidean.PerpBisector

   namespace myNameSpace


   open Isometry
   open Set
   open scoped RealInnerProductSpace
   variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace â„ V] [MetricSpace P]
   variable [NormedAddTorsor V P]
   variable [NormedAddTorsor V P]
   variable {c câ‚ câ‚‚ pâ‚ pâ‚‚ : P}
   open AffineSubspace
   variable {V' P' : Type*} [NormedAddCommGroup V'] [InnerProductSpace â„ V'] [MetricSpace P']
   variable [NormedAddTorsor V' P']
   variable [NormedAddTorsor V' P']

   theorem Isometry.preimage_perpBisector {f : P â†’ P'} (h : Isometry f) (pâ‚ pâ‚‚ : P) :
       f â»Â¹' (perpBisector (f pâ‚) (f pâ‚‚)) = perpBisector pâ‚ pâ‚‚ := by
     ext x; simp [mem_perpBisector_iff_dist_eq, h.dist_eq]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "ext x",
      "proofState": 0,
      "pos": {"line": 22, "column": 2},
      "goals":
      "V : Type u_1\nP : Type u_2\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : InnerProductSpace â„ V\ninstâœâ· : MetricSpace P\ninstâœâ¶ instâœâµ : NormedAddTorsor V P\nV' : Type u_3\nP' : Type u_4\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V'\ninstâœÂ² : MetricSpace P'\ninstâœÂ¹ instâœ : NormedAddTorsor V' P'\nf : P â†’ P'\nh : Isometry f\npâ‚ pâ‚‚ : P\nâŠ¢ f â»Â¹' â†‘(perpBisector (f pâ‚) (f pâ‚‚)) = â†‘(perpBisector pâ‚ pâ‚‚)",
      "endPos": {"line": 22, "column": 7}},
     {"tactic": "simp [mem_perpBisector_iff_dist_eq, h.dist_eq]",
      "proofState": 1,
      "pos": {"line": 22, "column": 9},
      "goals":
      "case h\nV : Type u_1\nP : Type u_2\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : InnerProductSpace â„ V\ninstâœâ· : MetricSpace P\ninstâœâ¶ instâœâµ : NormedAddTorsor V P\nV' : Type u_3\nP' : Type u_4\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V'\ninstâœÂ² : MetricSpace P'\ninstâœÂ¹ instâœ : NormedAddTorsor V' P'\nf : P â†’ P'\nh : Isometry f\npâ‚ pâ‚‚ x : P\nâŠ¢ x âˆˆ f â»Â¹' â†‘(perpBisector (f pâ‚) (f pâ‚‚)) â†” x âˆˆ â†‘(perpBisector pâ‚ pâ‚‚)",
      "endPos": {"line": 22, "column": 55}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 20, "column": 0},
      "endPos": {"line": 22, "column": 55},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.Isometry.preimage_perpBisector':\n  [NormedAddTorsor V P]\n  [NormedAddTorsor V' P']\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [NormedAddTorsor V P] [NormedAddTorsor V' P'] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 31
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_of_not_aemeasurable (hf : Â¬ AEMeasurable f Î¼) : Î¼.tilted f = 0 := by
     refine tilted_of_not_integrable ?_
     suffices Â¬ AEMeasurable (fun x â†¦ exp (f x)) Î¼ by exact fun h â†¦ this h.1.aemeasurable
     exact fun h â†¦ hf (aemeasurable_of_aemeasurable_exp h)

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "refine tilted_of_not_integrable ?_",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± f : Î± â†’ â„ hf : Â¬AEMeasurable f Î¼ âŠ¢ Î¼.tilted f = 0",
      "endPos": {"line": 13, "column": 36}},
     {"tactic":
      "suffices Â¬AEMeasurable (fun x â†¦ exp (f x)) Î¼ by exact fun h â†¦ this h.1.aemeasurable",
      "proofState": 1,
      "pos": {"line": 14, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± f : Î± â†’ â„ hf : Â¬AEMeasurable f Î¼ âŠ¢ Â¬Integrable (fun x => rexp (f x)) Î¼",
      "endPos": {"line": 14, "column": 86}},
     {"tactic": "exact fun h â†¦ this h.1.aemeasurable",
      "proofState": 2,
      "pos": {"line": 14, "column": 51},
      "goals":
      "Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ : Measure Î±\nf : Î± â†’ â„\nhf : Â¬AEMeasurable f Î¼\nthis : Â¬AEMeasurable (fun x => rexp (f x)) Î¼\nâŠ¢ Â¬Integrable (fun x => rexp (f x)) Î¼",
      "endPos": {"line": 14, "column": 86}},
     {"tactic": "exact fun h â†¦ hf (aemeasurable_of_aemeasurable_exp h)",
      "proofState": 3,
      "pos": {"line": 15, "column": 2},
      "goals":
      "Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ : Measure Î±\nf : Î± â†’ â„\nhf : Â¬AEMeasurable f Î¼\nâŠ¢ Â¬AEMeasurable (fun x => rexp (f x)) Î¼",
      "endPos": {"line": 15, "column": 55}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 32
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_ne_zero : aâ»Â¹ â‰  0 â†” a â‰  âˆ := by
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ aâ»Â¹ â‰  0 â†” a â‰  âŠ¤",
      "endPos": {"line": 12, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 33
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_lt_top {x : â„â‰¥0âˆ} : xâ»Â¹ < âˆ â†” 0 < x := by
     simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "x : â„â‰¥0âˆ âŠ¢ xâ»Â¹ < âŠ¤ â†” 0 < x",
      "endPos": {"line": 12, "column": 60}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 34
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_snd {G : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ G)
       (p : YonedaCollection F X) : (YonedaCollection.mapâ‚ Î· p).snd =
         G.map (eqToHom (by rw [YonedaCollection.mapâ‚_fst])) (Î·.app _ p.snd) := by
     simp [mapâ‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [YonedaCollection.mapâ‚_fst]",
      "proofState": 0,
      "pos": {"line": 17, "column": 25},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nG : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ G\np : YonedaCollection F X\nâŠ¢ op (CostructuredArrow.mk p.fst) = op (CostructuredArrow.mk (mapâ‚ Î· p).fst)",
      "endPos": {"line": 17, "column": 55}},
     {"tactic": "simp [mapâ‚]",
      "proofState": 1,
      "pos": {"line": 18, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nG : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ G\np : YonedaCollection F X\nâŠ¢ (mapâ‚ Î· p).snd = G.map (eqToHom â‹¯) (Î·.app (op (CostructuredArrow.mk p.fst)) p.snd)",
      "endPos": {"line": 18, "column": 13}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 35
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_fst {G : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ G)
       (p : YonedaCollection F X) : (YonedaCollection.mapâ‚ Î· p).fst = p.fst := by
     simp [mapâ‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [mapâ‚]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nG : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ G\np : YonedaCollection F X\nâŠ¢ (mapâ‚ Î· p).fst = p.fst",
      "endPos": {"line": 17, "column": 13}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 36
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.unitForward_naturalityâ‚ {F G : Cáµ’áµ– â¥¤ Type v} {Î· : F âŸ¶ A} {Î¼ : G âŸ¶ A} (Îµ : F âŸ¶ G)
       (hÎµ : Îµ â‰« Î¼ = Î·) (X : C) (p : YonedaCollection (restrictedYonedaObj Î·) X) :
       unitForward Î¼ X (p.mapâ‚ (restrictedYonedaObjMapâ‚ Îµ hÎµ)) = Îµ.app _ (unitForward Î· X p) := by
     simp [unitForward]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [unitForward]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA F G : Cáµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ A\nÎ¼ : G âŸ¶ A\nÎµ : F âŸ¶ G\nhÎµ : Îµ â‰« Î¼ = Î·\nX : C\np : YonedaCollection (restrictedYonedaObj Î·) X\nâŠ¢ unitForward Î¼ X (YonedaCollection.mapâ‚ (restrictedYonedaObjMapâ‚ Îµ hÎµ) p) = Îµ.app (op X) (unitForward Î· X p)",
      "endPos": {"line": 17, "column": 20}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 37
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}

   theorem CategoryTheory.OverPresheafAux.map_mkPrecomp_eqToHom {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X Y : C} {f : X âŸ¶ Y}
       {g g' : yoneda.obj Y âŸ¶ A} (h : g = g') {x : F.obj (op (CostructuredArrow.mk g'))} :
       F.map (CostructuredArrow.mkPrecomp g f).op (F.map (eqToHom (by rw [h])) x) =
         F.map (eqToHom (by rw [h])) (F.map (CostructuredArrow.mkPrecomp g' f).op x) := by
     aesop_cat

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [h]",
      "proofState": 0,
      "pos": {"line": 15, "column": 67},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\ng g' : yoneda.obj Y âŸ¶ A\nh : g = g'\nx : F.obj (op (CostructuredArrow.mk g'))\nâŠ¢ op (CostructuredArrow.mk g') = op (CostructuredArrow.mk g)",
      "endPos": {"line": 15, "column": 73}},
     {"tactic": "rw [h]",
      "proofState": 1,
      "pos": {"line": 16, "column": 25},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\ng g' : yoneda.obj Y âŸ¶ A\nh : g = g'\nx : F.obj (op (CostructuredArrow.mk g'))\nâŠ¢ op (CostructuredArrow.mk (yoneda.map f â‰« g')) = op (CostructuredArrow.mk (yoneda.map f â‰« g))",
      "endPos": {"line": 16, "column": 31}},
     {"tactic": "aesop_cat",
      "proofState": 2,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\ng g' : yoneda.obj Y âŸ¶ A\nh : g = g'\nx : F.obj (op (CostructuredArrow.mk g'))\nâŠ¢ F.map (CostructuredArrow.mkPrecomp g f).op (F.map (eqToHom â‹¯) x) =\n    F.map (eqToHom â‹¯) (F.map (CostructuredArrow.mkPrecomp g' f).op x)",
      "endPos": {"line": 17, "column": 11}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 38
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚‚_comp {Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :
       YonedaCollection.mapâ‚‚ F (f â‰« g) = YonedaCollection.mapâ‚‚ F f âˆ˜ YonedaCollection.mapâ‚‚ F g := by
     ext; all_goals simp

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:83: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ—] row 39
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_mapâ‚‚ {G : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ G) {Y : C} (f : X âŸ¶ Y)
       (p : YonedaCollection F Y) :
       YonedaCollection.mapâ‚‚ G f (YonedaCollection.mapâ‚ Î· p) =
         YonedaCollection.mapâ‚ Î· (YonedaCollection.mapâ‚‚ F f p) := by
     ext; all_goals simp

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:99: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 40
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open OverArrows
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.OverArrows.yonedaCollectionPresheafToA_val_fst (s : yoneda.obj X âŸ¶ A)
       (p : OverArrows (yonedaCollectionPresheafToA F) s) : p.val.fst = s := by
     simpa [YonedaCollection.yonedaEquivFst_eq] using p.app_val

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa [YonedaCollection.yonedaEquivFst_eq] using p.app_val",
      "proofState": 0,
      "pos": {"line": 18, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\ns : yoneda.obj X âŸ¶ A\np : OverArrows (yonedaCollectionPresheafToA F) s\nâŠ¢ YonedaCollection.fst p.val = s",
      "endPos": {"line": 18, "column": 60}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 18, "column": 2},
      "endPos": {"line": 18, "column": 60},
      "data":
      "try 'simp' instead of 'simpa'\nnote: this linter can be disabled with `set_option linter.unnecessarySimpa false`"}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 41
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚‚_yonedaEquivFst {Y : C} (f : X âŸ¶ Y) (p : YonedaCollection F Y) :
       (YonedaCollection.mapâ‚‚ F f p).yonedaEquivFst = A.map f.op p.yonedaEquivFst := by
     simp only [YonedaCollection.yonedaEquivFst_eq, mapâ‚‚_fst, yonedaEquiv_naturality]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "simp only [YonedaCollection.yonedaEquivFst_eq, mapâ‚‚_fst, yonedaEquiv_naturality]",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX Y : C\nf : X âŸ¶ Y\np : YonedaCollection F Y\nâŠ¢ (mapâ‚‚ F f p).yonedaEquivFst = A.map f.op p.yonedaEquivFst",
      "endPos": {"line": 17, "column": 82}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 42
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_mul_le_iff {x y z : â„â‰¥0âˆ} (h1 : x â‰  0) (h2 : x â‰  âˆ) :
       xâ»Â¹ * y â‰¤ z â†” y â‰¤ x * z := by
     rw [â† mul_le_mul_left h1 h2, â† mul_assoc, ENNReal.mul_inv_cancel h1 h2, one_mul]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "rw [â† mul_le_mul_left h1 h2, â† mul_assoc, ENNReal.mul_inv_cancel h1 h2, one_mul]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "x y z : â„â‰¥0âˆ h1 : x â‰  0 h2 : x â‰  âŠ¤ âŠ¢ xâ»Â¹ * y â‰¤ z â†” y â‰¤ x * z",
      "endPos": {"line": 13, "column": 82}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 43
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.mapâ‚_comp {G H : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ G) (Î¼ : G âŸ¶ H) :
       YonedaCollection.mapâ‚ (Î· â‰« Î¼) (X := X) =
         YonedaCollection.mapâ‚ Î¼ (X := X) âˆ˜ YonedaCollection.mapâ‚ Î· (X := X) := by
     ext; all_goals simp

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:101: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ—] row 44
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem IsFreeGroup.unique_lift (f : Generators G â†’ H) : âˆƒ! F : G â†’* H, âˆ€ a, F (of a) = f a := by
     simpa only [Function.funext_iff] using lift.symm.bijective.existsUnique f

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:58: unexpected token '!'; expected '(', '_' or identifier
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 45
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.mul_inv_le_iff {x y z : â„â‰¥0âˆ} (h1 : y â‰  0) (h2 : y â‰  âˆ) :
       x * yâ»Â¹ â‰¤ z â†” x â‰¤ z * y := by
     rw [mul_comm, ENNReal.inv_mul_le_iff h1 h2, mul_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [mul_comm, ENNReal.inv_mul_le_iff h1 h2, mul_comm]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "x y z : â„â‰¥0âˆ h1 : y â‰  0 h2 : y â‰  âŠ¤ âŠ¢ x * yâ»Â¹ â‰¤ z â†” x â‰¤ z * y",
      "endPos": {"line": 13, "column": 55}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 46
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_le_iff' {x y z : â„â‰¥0âˆ} (h1 : y â‰  0) (h2 : y â‰  âˆ) :
       x / y â‰¤ z â†” x â‰¤ y * z := by
     rw [mul_comm, ENNReal.div_le_iff h1 h2]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [mul_comm, ENNReal.div_le_iff h1 h2]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "x y z : â„â‰¥0âˆ h1 : y â‰  0 h2 : y â‰  âŠ¤ âŠ¢ x / y â‰¤ z â†” x â‰¤ y * z",
      "endPos": {"line": 13, "column": 41}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 47
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_zero_measure (f : Î± â†’ â„) : (0 : Measure Î±).tilted f = 0 := by
     simp [Measure.tilted]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [Measure.tilted]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± f : Î± â†’ â„ âŠ¢ Measure.tilted 0 f = 0",
      "endPos": {"line": 13, "column": 23}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 48
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open YonedaCollection
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.YonedaCollection.ext {p q : YonedaCollection F X} (h : p.fst = q.fst)
       (h' : F.map (eqToHom <| by rw [h]) q.snd = p.snd) : p = q := by
     rcases p with âŸ¨p, p'âŸ©
     rcases q with âŸ¨q, q'âŸ©
     obtain rfl : p = q := yonedaEquiv.symm.injective h
     exact Sigma.ext rfl (by simpa [snd] using h'.symm)

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [h]",
      "proofState": 0,
      "pos": {"line": 16, "column": 31},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\np q : YonedaCollection F X\nh : p.fst = q.fst\nâŠ¢ op (CostructuredArrow.mk q.fst) = op (CostructuredArrow.mk p.fst)",
      "endPos": {"line": 16, "column": 37}},
     {"tactic": "rcases p with âŸ¨p, p'âŸ©",
      "proofState": 1,
      "pos": {"line": 17, "column": 2},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\np q : YonedaCollection F X\nh : p.fst = q.fst\nh' : F.map (eqToHom â‹¯) q.snd = p.snd\nâŠ¢ p = q",
      "endPos": {"line": 17, "column": 23}},
     {"tactic": "rcases q with âŸ¨q, q'âŸ©",
      "proofState": 2,
      "pos": {"line": 18, "column": 2},
      "goals":
      "case mk\nC : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\nq : YonedaCollection F X\np : A.obj (op X)\np' : F.obj (op (CostructuredArrow.mk (yonedaEquiv.symm p)))\nh : fst âŸ¨p, p'âŸ© = q.fst\nh' : F.map (eqToHom â‹¯) q.snd = snd âŸ¨p, p'âŸ©\nâŠ¢ âŸ¨p, p'âŸ© = q",
      "endPos": {"line": 18, "column": 23}},
     {"tactic": "obtain rfl : p = q := yonedaEquiv.symm.injective h",
      "proofState": 3,
      "pos": {"line": 19, "column": 2},
      "goals":
      "case mk.mk\nC : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\np : A.obj (op X)\np' : F.obj (op (CostructuredArrow.mk (yonedaEquiv.symm p)))\nq : A.obj (op X)\nq' : F.obj (op (CostructuredArrow.mk (yonedaEquiv.symm q)))\nh : fst âŸ¨p, p'âŸ© = fst âŸ¨q, q'âŸ©\nh' : F.map (eqToHom â‹¯) (snd âŸ¨q, q'âŸ©) = snd âŸ¨p, p'âŸ©\nâŠ¢ âŸ¨p, p'âŸ© = âŸ¨q, q'âŸ©",
      "endPos": {"line": 19, "column": 52}},
     {"tactic": "exact Sigma.ext rfl (by simpa [snd] using h'.symm)",
      "proofState": 4,
      "pos": {"line": 20, "column": 2},
      "goals":
      "case mk.mk\nC : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\np : A.obj (op X)\np' q' : F.obj (op (CostructuredArrow.mk (yonedaEquiv.symm p)))\nh : fst âŸ¨p, p'âŸ© = fst âŸ¨p, q'âŸ©\nh' : F.map (eqToHom â‹¯) (snd âŸ¨p, q'âŸ©) = snd âŸ¨p, p'âŸ©\nâŠ¢ âŸ¨p, p'âŸ© = âŸ¨p, q'âŸ©",
      "endPos": {"line": 20, "column": 52}},
     {"tactic": "simpa [snd] using h'.symm",
      "proofState": 5,
      "pos": {"line": 20, "column": 26},
      "goals":
      "C : Type u\ninstâœ : Category.{v, u} C\nA : Cáµ’áµ– â¥¤ Type v\nF : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v\nX : C\np : A.obj (op X)\np' q' : F.obj (op (CostructuredArrow.mk (yonedaEquiv.symm p)))\nh : fst âŸ¨p, p'âŸ© = fst âŸ¨p, q'âŸ©\nh' : F.map (eqToHom â‹¯) (snd âŸ¨p, q'âŸ©) = snd âŸ¨p, p'âŸ©\nâŠ¢ HEq âŸ¨p, p'âŸ©.snd âŸ¨p, q'âŸ©.snd",
      "endPos": {"line": 20, "column": 51}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 49
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_le_iff {x y z : â„â‰¥0âˆ} (h1 : y â‰  0) (h2 : y â‰  âˆ) :
       x / y â‰¤ z â†” x â‰¤ z * y := by
     rw [div_eq_mul_inv, ENNReal.mul_inv_le_iff h1 h2]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [div_eq_mul_inv, ENNReal.mul_inv_le_iff h1 h2]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "x y z : â„â‰¥0âˆ h1 : y â‰  0 h2 : y â‰  âŠ¤ âŠ¢ x / y â‰¤ z â†” x â‰¤ z * y",
      "endPos": {"line": 13, "column": 51}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 50
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_of_not_integrable (hf : Â¬ Integrable (fun x â†¦ exp (f x)) Î¼) : Î¼.tilted f = 0 := by
     rw [Measure.tilted, integral_undef hf]
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [Measure.tilted, integral_undef hf]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± f : Î± â†’ â„ hf : Â¬Integrable (fun x => rexp (f x)) Î¼ âŠ¢ Î¼.tilted f = 0",
      "endPos": {"line": 13, "column": 40}},
     {"tactic": "simp",
      "proofState": 1,
      "pos": {"line": 14, "column": 2},
      "goals":
      "Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ : Measure Î±\nf : Î± â†’ â„\nhf : Â¬Integrable (fun x => rexp (f x)) Î¼\nâŠ¢ (Î¼.withDensity fun x => ENNReal.ofReal (rexp (f x) / 0)) = 0",
      "endPos": {"line": 14, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 51
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_zero (Î¼ : Measure Î±) [IsProbabilityMeasure Î¼] : Î¼.tilted 0 = Î¼ := by
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± instâœ : IsProbabilityMeasure Î¼ âŠ¢ Î¼.tilted 0 = Î¼",
      "endPos": {"line": 13, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 52
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.CategoryTheory.Comma.Over
   import Mathlib.Tactic.CategoryTheory.Elementwise
   import Mathlib.CategoryTheory.Comma.Presheaf

   namespace myNameSpace


   open CategoryTheory
   open OverPresheafAux
   open Category Opposite
   variable {C : Type u} [Category.{v} C] {A : Cáµ’áµ– â¥¤ Type v}
   variable {F : (CostructuredArrow yoneda A)áµ’áµ– â¥¤ Type v} {X : C}

   theorem CategoryTheory.OverPresheafAux.unitBackward_unitForward {F : Cáµ’áµ– â¥¤ Type v} (Î· : F âŸ¶ A) (X : C) :
       unitBackward Î· X âˆ˜ unitForward Î· X = id := by
     refine funext fun p => YonedaCollection.ext ?_ (OverArrows.ext ?_)
     Â· simpa [unitForward, unitBackward] using congrArg yonedaEquiv.symm p.snd.app_val
     Â· simp [unitForward, unitBackward]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "refine funext fun p => YonedaCollection.ext ?_ (OverArrows.ext ?_)",
      "proofState": 0,
      "pos": {"line": 16, "column": 2},
      "goals":
      "C : Type u instâœ : Category.{v, u} C A F : Cáµ’áµ– â¥¤ Type v Î· : F âŸ¶ A X : C âŠ¢ unitBackward Î· X âˆ˜ unitForward Î· X = id",
      "endPos": {"line": 16, "column": 68}},
     {"tactic":
      "simpa [unitForward, unitBackward] using congrArg yonedaEquiv.symm p.snd.app_val",
      "proofState": 1,
      "pos": {"line": 17, "column": 4},
      "goals":
      "case refine_1\nC : Type u\ninstâœ : Category.{v, u} C\nA F : Cáµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ A\nX : C\np : YonedaCollection (restrictedYonedaObj Î·) X\nâŠ¢ ((unitBackward Î· X âˆ˜ unitForward Î· X) p).fst = (id p).fst",
      "endPos": {"line": 17, "column": 83}},
     {"tactic": "simp [unitForward, unitBackward]",
      "proofState": 2,
      "pos": {"line": 18, "column": 4},
      "goals":
      "case refine_2\nC : Type u\ninstâœ : Category.{v, u} C\nA F : Cáµ’áµ– â¥¤ Type v\nÎ· : F âŸ¶ A\nX : C\np : YonedaCollection (restrictedYonedaObj Î·) X\nâŠ¢ OverArrows.val ((restrictedYonedaObj Î·).map (eqToHom â‹¯) (id p).snd) =\n    OverArrows.val ((unitBackward Î· X âˆ˜ unitForward Î· X) p).snd",
      "endPos": {"line": 18, "column": 36}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 53
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.MeasureTheory.Decomposition.RadonNikodym
   import Mathlib.MeasureTheory.Measure.Tilted

   namespace myNameSpace


   open MeasureTheory
   open Real
   open scoped ENNReal NNReal
   variable {Î± : Type*} {mÎ± : MeasurableSpace Î±} {Î¼ : Measure Î±} {f : Î± â†’ â„}

   theorem MeasureTheory.tilted_const (Î¼ : Measure Î±) [IsProbabilityMeasure Î¼] (c : â„) :
       Î¼.tilted (fun _ â†¦ c) = Î¼ := by
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp",
      "proofState": 0,
      "pos": {"line": 14, "column": 2},
      "goals":
      "Î± : Type u_1 mÎ± : MeasurableSpace Î± Î¼ : Measure Î± instâœ : IsProbabilityMeasure Î¼ c : â„ âŠ¢ (Î¼.tilted fun x => c) = Î¼",
      "endPos": {"line": 14, "column": 6}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 54
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsFixedBlock.isBlock {B : Set X} (hfB : IsFixedBlock G B) :
       IsBlock G B := by
     simp [IsBlock.def, hfB _]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:44: function expected at
       Set
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:6:58: function expected at
       IsFixedBlock
     term has type
       ?m.10
     error: ././././TmpProjDir/Basic.lean:7:4: function expected at



   ================================================================================
[âœ—] row 55
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsBlock.def {B : Set X} :
       IsBlock G B â†” âˆ€ g g' : G, g â€¢ B = g' â€¢ B âˆ¨ Disjoint (g â€¢ B) (g' â€¢ B) := by
     apply Set.pairwiseDisjoint_range_iff

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:32: expected token
     error: ././././TmpProjDir/Basic.lean:7:30: type expected, got
       (g : G)
     error: ././././TmpProjDir/Basic.lean:6:35: function expected at
       Set
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:7:4: function expected at
       IsBlock



   ================================================================================
[âœ—] row 56
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsBlock.mk_notempty {B : Set X} :
       IsBlock G B â†” âˆ€ g g' : G, g â€¢ B âˆ© g' â€¢ B â‰  âˆ… â†’ g â€¢ B = g' â€¢ B := by
     simp_rw [IsBlock.def, or_iff_not_imp_right, Set.disjoint_iff_inter_eq_empty]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:32: expected token
     error: ././././TmpProjDir/Basic.lean:7:30: type expected, got
       (g : G)
     error: ././././TmpProjDir/Basic.lean:6:43: function expected at
       Set
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:7:4: function expected at
       IsBlock



   ================================================================================
[âœ—] row 57
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.isBlock_empty : IsBlock G (âŠ¥ : Set X) := by
     simp [IsBlock.def, Set.bot_eq_empty, Set.smul_set_empty]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:45: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ—] row 58
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsBlock.mk_notempty_one {B : Set X} :
       IsBlock G B â†” âˆ€ g : G, g â€¢ B âˆ© B â‰  âˆ… â†’ g â€¢ B = B := by
     simp_rw [IsBlock.def_one, Set.disjoint_iff_inter_eq_empty, or_iff_not_imp_right]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:29: expected token
     error: ././././TmpProjDir/Basic.lean:7:27: type expected, got
       (g : G)
     error: ././././TmpProjDir/Basic.lean:6:47: function expected at
       Set
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:7:4: function expected at
       IsBlock



   ================================================================================
[âœ“] row 59
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.Setoid.Partition
   import Mathlib.GroupTheory.GroupAction.Basic
   import Mathlib.GroupTheory.GroupAction.Pointwise
   import Mathlib.GroupTheory.GroupAction.SubMulAction
   import Mathlib.GroupTheory.GroupAction.Blocks

   namespace myNameSpace


   open MulAction
   open orbit
   open scoped BigOperators Pointwise
   variable {G : Type*} [Group G] {X : Type*} [MulAction G X]

   theorem MulAction.orbit.pairwiseDisjoint :
       (Set.range fun x : X => orbit G x).PairwiseDisjoint id := by
     rintro s âŸ¨x, rflâŸ© t âŸ¨y, rflâŸ© h
     contrapose! h
     exact (orbit.eq_or_disjoint x y).resolve_right h

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rintro s âŸ¨x, rflâŸ© t âŸ¨y, rflâŸ© h",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "G : Type u_1 instâœÂ¹ : Group G X : Type u_2 instâœ : MulAction G X âŠ¢ (Set.range fun x => orbit G x).PairwiseDisjoint id",
      "endPos": {"line": 17, "column": 32}},
     {"tactic": "contrapose! h",
      "proofState": 1,
      "pos": {"line": 18, "column": 2},
      "goals":
      "case intro.intro\nG : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\nx y : X\nh : (fun x => orbit G x) x â‰  (fun x => orbit G x) y\nâŠ¢ (Disjoint on id) ((fun x => orbit G x) x) ((fun x => orbit G x) y)",
      "endPos": {"line": 18, "column": 15}},
     {"tactic": "exact (orbit.eq_or_disjoint x y).resolve_right h",
      "proofState": 2,
      "pos": {"line": 19, "column": 2},
      "goals":
      "case intro.intro\nG : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\nx y : X\nh : Â¬(Disjoint on id) (orbit G x) (orbit G y)\nâŠ¢ orbit G x = orbit G y",
      "endPos": {"line": 19, "column": 50}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 60
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.lt_inv_iff_lt_inv : a < bâ»Â¹ â†” b < aâ»Â¹ := by
     simpa only [inv_inv] using @ENNReal.inv_lt_inv aâ»Â¹ b

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa only [inv_inv] using @ENNReal.inv_lt_inv aâ»Â¹ b",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ a < bâ»Â¹ â†” b < aâ»Â¹",
      "endPos": {"line": 12, "column": 54}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 61
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.isBlock_singleton (a : X) : IsBlock G ({a} : Set X) := by
     simp [IsBlock.def, Classical.or_iff_not_imp_left]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:46: function expected at
       IsBlock
     term has type
       ?m.9
     error: ././././TmpProjDir/Basic.lean:7:8: invalid field notation, type is not of the form (C ...) where C is a constant
       IsBlock
     has type
       xâœ
     error: ././././TmpProjDir/Basic.lean:7:2: simp made no progress



   ================================================================================
[âœ“] row 62
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.Setoid.Partition
   import Mathlib.GroupTheory.GroupAction.Basic
   import Mathlib.GroupTheory.GroupAction.Pointwise
   import Mathlib.GroupTheory.GroupAction.SubMulAction
   import Mathlib.GroupTheory.GroupAction.Blocks

   namespace myNameSpace


   open MulAction
   open orbit
   open scoped BigOperators Pointwise
   variable {G : Type*} [Group G] {X : Type*} [MulAction G X]

   theorem MulAction.orbit.eq_or_disjoint (a b : X) :
       orbit G a = orbit G b âˆ¨ Disjoint (orbit G a) (orbit G b) := by
     apply (em (Disjoint (orbit G a) (orbit G b))).symm.imp _ id
     simp (config := { contextual := true })
       only [Set.not_disjoint_iff, â† orbit_eq_iff, forall_exists_index, and_imp, eq_comm, implies_true]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "apply (em (Disjoint (orbit G a) (orbit G b))).symm.imp _ id",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "G : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\na b : X\nâŠ¢ orbit G a = orbit G b âˆ¨ Disjoint (orbit G a) (orbit G b)",
      "endPos": {"line": 17, "column": 61}},
     {"tactic":
      "simp (config := { contextual := true }) only [Set.not_disjoint_iff, â† orbit_eq_iff, forall_exists_index, and_imp,\n  eq_comm, implies_true]",
      "proofState": 1,
      "pos": {"line": 18, "column": 2},
      "goals":
      "G : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\na b : X\nâŠ¢ Â¬Disjoint (orbit G a) (orbit G b) â†’ orbit G a = orbit G b",
      "endPos": {"line": 19, "column": 100}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 63
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_lt_iff_inv_lt : aâ»Â¹ < b â†” bâ»Â¹ < a := by
     simpa only [inv_inv] using @ENNReal.inv_lt_inv a bâ»Â¹

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa only [inv_inv] using @ENNReal.inv_lt_inv a bâ»Â¹",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ aâ»Â¹ < b â†” bâ»Â¹ < a",
      "endPos": {"line": 12, "column": 54}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 64
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.Setoid.Partition
   import Mathlib.GroupTheory.GroupAction.Basic
   import Mathlib.GroupTheory.GroupAction.Pointwise
   import Mathlib.GroupTheory.GroupAction.SubMulAction
   import Mathlib.GroupTheory.GroupAction.Blocks

   namespace myNameSpace


   open MulAction
   open IsPartition
   open scoped BigOperators Pointwise
   variable {G : Type*} [Group G] {X : Type*} [MulAction G X]

   theorem MulAction.IsPartition.of_orbits :
       Setoid.IsPartition (Set.range fun a : X => orbit G a) := by
     apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty
     Â· intro x
       exact âŸ¨_, âŸ¨x, rflâŸ©, mem_orbit_self xâŸ©
     Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
       exact (MulAction.orbit_nonempty a).ne_empty ha

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty",
      "proofState": 0,
      "pos": {"line": 17, "column": 2},
      "goals":
      "G : Type u_1 instâœÂ¹ : Group G X : Type u_2 instâœ : MulAction G X âŠ¢ Setoid.IsPartition (Set.range fun a => orbit G a)",
      "endPos": {"line": 17, "column": 64}},
     {"tactic": "intro x",
      "proofState": 1,
      "pos": {"line": 18, "column": 4},
      "goals":
      "case hâ‚‚\nG : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\nâŠ¢ âˆ€ (a : X), âˆƒ x âˆˆ Set.range fun x => orbit G x, a âˆˆ x",
      "endPos": {"line": 18, "column": 11}},
     {"tactic": "exact âŸ¨_, âŸ¨x, rflâŸ©, mem_orbit_self xâŸ©",
      "proofState": 2,
      "pos": {"line": 19, "column": 4},
      "goals":
      "case hâ‚‚\nG : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\nx : X\nâŠ¢ âˆƒ x_1 âˆˆ Set.range fun x => orbit G x, x âˆˆ x_1",
      "endPos": {"line": 19, "column": 41}},
     {"tactic": "rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©",
      "proofState": 3,
      "pos": {"line": 20, "column": 4},
      "goals":
      "case hâ‚ƒ G : Type u_1 instâœÂ¹ : Group G X : Type u_2 instâœ : MulAction G X âŠ¢ âˆ… âˆ‰ Set.range fun x => orbit G x",
      "endPos": {"line": 20, "column": 34}},
     {"tactic": "exact (MulAction.orbit_nonempty a).ne_empty ha",
      "proofState": 4,
      "pos": {"line": 21, "column": 4},
      "goals":
      "case hâ‚ƒ.intro G : Type u_1 instâœÂ¹ : Group G X : Type u_2 instâœ : MulAction G X a : X ha : orbit G a = âˆ… âŠ¢ False",
      "endPos": {"line": 21, "column": 50}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 65
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.top_div_of_ne_top (h : a â‰  âˆ) : âˆ / a = âˆ := by
     simp [top_div, h]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [top_div, h]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ h : a â‰  âŠ¤ âŠ¢ âŠ¤ / a = âŠ¤",
      "endPos": {"line": 12, "column": 19}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 66
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_le_one : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a := by
     rw [inv_le_iff_inv_le, inv_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [inv_le_iff_inv_le, inv_one]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
      "endPos": {"line": 12, "column": 33}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 67
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.one_lt_inv : 1 < aâ»Â¹ â†” a < 1 := by
     rw [lt_inv_iff_lt_inv, inv_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [lt_inv_iff_lt_inv, inv_one]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ 1 < aâ»Â¹ â†” a < 1",
      "endPos": {"line": 12, "column": 33}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 68
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsBlock.subgroup {H : Subgroup G} {B : Set X} (hfB : IsBlock G B) :
       IsBlock H B := by
     rw [IsBlock.def_one]; rintro âŸ¨g, _âŸ©
     simpa only using hfB.smul_eq_or_disjoint g

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:40: function expected at
       Subgroup
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:6:57: function expected at
       Set
     term has type
       ?m.10
     error: ././././TmpProjDir/Basic.lean:6:71: function expected at



   ================================================================================
[âœ“] row 69
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_top : a / âˆ = 0 := by
     rw [div_eq_mul_inv, inv_top, mul_zero]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [div_eq_mul_inv, inv_top, mul_zero]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ a / âŠ¤ = 0",
      "endPos": {"line": 12, "column": 40}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 70
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.one_le_inv : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1 := by
     rw [le_inv_iff_le_inv, inv_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [le_inv_iff_le_inv, inv_one]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
      "endPos": {"line": 12, "column": 33}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 71
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.sub_div (h : 0 < b â†’ b < a â†’ c â‰  0) : (a - b) / c = a / c - b / c := by
     simp_rw [div_eq_mul_inv]
     exact ENNReal.sub_mul (by simpa using h)

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp_rw [div_eq_mul_inv]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals":
      "a b c : â„â‰¥0âˆ h : 0 < b â†’ b < a â†’ c â‰  0 âŠ¢ (a - b) / c = a / c - b / c",
      "endPos": {"line": 12, "column": 26}},
     {"tactic": "exact ENNReal.sub_mul (by simpa using h)",
      "proofState": 1,
      "pos": {"line": 13, "column": 2},
      "goals":
      "a b c : â„â‰¥0âˆ h : 0 < b â†’ b < a â†’ c â‰  0 âŠ¢ (a - b) * câ»Â¹ = a * câ»Â¹ - b * câ»Â¹",
      "endPos": {"line": 13, "column": 42}},
     {"tactic": "simpa using h",
      "proofState": 2,
      "pos": {"line": 13, "column": 28},
      "goals": "a b c : â„â‰¥0âˆ h : 0 < b â†’ b < a â†’ c â‰  0 âŠ¢ 0 < b â†’ b < a â†’ câ»Â¹ â‰  âŠ¤",
      "endPos": {"line": 13, "column": 41}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 72
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_mul_le_one (a : â„â‰¥0âˆ) : aâ»Â¹ * a â‰¤ 1 := by
     simp [mul_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [mul_comm]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ aâ»Â¹ * a â‰¤ 1",
      "endPos": {"line": 12, "column": 17}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 73
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.IsBlock.smul_eq_or_disjoint {B : Set X} (hB : IsBlock G B) (g : G) :
       g â€¢ B = B âˆ¨ Disjoint (g â€¢ B) B := by
     rw [IsBlock.def] at hB
     simpa only [one_smul] using hB g 1

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:6: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 74
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.le_inv_iff_le_inv : a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹ := by
     simpa only [inv_inv] using @ENNReal.inv_le_inv aâ»Â¹ b

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa only [inv_inv] using @ENNReal.inv_le_inv aâ»Â¹ b",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹",
      "endPos": {"line": 12, "column": 54}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 75
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.mul_div_mul_right (a b : â„â‰¥0âˆ) (hc : c â‰  0) (hc' : c â‰  âŠ¤) :
       a * c / (b * c) = a / b := by
     rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inr hc') (Or.inr hc), mul_mul_mul_comm,
       ENNReal.mul_inv_cancel hc hc', mul_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inr hc') (Or.inr hc), mul_mul_mul_comm,\n  ENNReal.mul_inv_cancel hc hc', mul_one]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "c a b : â„â‰¥0âˆ hc : c â‰  0 hc' : c â‰  âŠ¤ âŠ¢ a * c / (b * c) = a / b",
      "endPos": {"line": 14, "column": 43}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 76
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_lt_one : aâ»Â¹ < 1 â†” 1 < a := by
     rw [inv_lt_iff_inv_lt, inv_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [inv_lt_iff_inv_lt, inv_one]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ aâ»Â¹ < 1 â†” 1 < a",
      "endPos": {"line": 12, "column": 33}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 77
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_mul_ne_top (a : â„â‰¥0âˆ) : aâ»Â¹ * a â‰  âŠ¤ := by
     simp [mul_comm]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [mul_comm]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ aâ»Â¹ * a â‰  âŠ¤",
      "endPos": {"line": 12, "column": 17}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 78
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.top_div : âˆ / a = if a = âˆ then 0 else âˆ := by
     simp [div_eq_mul_inv, top_mul']

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [div_eq_mul_inv, top_mul']",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ âŠ¤ / a = if a = âŠ¤ then 0 else âŠ¤",
      "endPos": {"line": 12, "column": 33}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 79
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_pos_iff : 0 < a / b â†” a â‰  0 âˆ§ b â‰  âˆ := by
     simp [pos_iff_ne_zero, not_or]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [pos_iff_ne_zero, not_or]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ 0 < a / b â†” a â‰  0 âˆ§ b â‰  âŠ¤",
      "endPos": {"line": 12, "column": 32}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 80
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.mul_lt_of_lt_div (h : a < b / c) : a * c < b := by
     contrapose! h
     exact ENNReal.div_le_of_le_mul h

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "contrapose! h",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b c : â„â‰¥0âˆ h : a < b / c âŠ¢ a * c < b",
      "endPos": {"line": 12, "column": 15}},
     {"tactic": "exact ENNReal.div_le_of_le_mul h",
      "proofState": 1,
      "pos": {"line": 13, "column": 2},
      "goals": "a b c : â„â‰¥0âˆ h : b â‰¤ a * c âŠ¢ b / c â‰¤ a",
      "endPos": {"line": 13, "column": 34}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 81
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MeasureTheory.rnDeriv_tilted_left {Î½ : Measure Î±} [SigmaFinite Î¼] [SigmaFinite Î½] (hfÎ½ : AEMeasurable f Î½) :
       (Î¼.tilted f).rnDeriv Î½
         =áµ[Î½] fun x â†¦ ENNReal.ofReal (exp (f x) / (âˆ« x, exp (f x) âˆ‚Î¼)) * Î¼.rnDeriv Î½ x := by
     let g := fun x â†¦ ENNReal.ofReal (exp (f x) / (âˆ« x, exp (f x) âˆ‚Î¼))
     refine Measure.rnDeriv_withDensity_left (Î¼ := Î¼) (Î½ := Î½) (f := g) ?_ ?_
     Â· exact ((measurable_exp.comp_aemeasurable hfÎ½).div_const _).ennreal_ofReal
     Â· exact ae_of_all _ (fun x â†¦ by simp [g])

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:8:7: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ—] row 82
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem MulAction.orbit.isBlock_of_normal {N : Subgroup G} [N.Normal] (a : X) :
       IsBlock G (orbit N a) := by
     rw [IsBlock.def_one]
     intro g
     rw [smul_orbit_eq_orbit_smul]
     apply orbit.eq_or_disjoint

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:60: invalid binder annotation, type is not a class instance
       ?m.9
     use the command `set_option checkBinderAnnotations false` to disable the check
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 83
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.mul_le_of_le_div (h : a â‰¤ b / c) : a * c â‰¤ b := by
     rw [â† inv_inv c]
     exact div_le_of_le_mul h

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [â† inv_inv c]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b c : â„â‰¥0âˆ h : a â‰¤ b / c âŠ¢ a * c â‰¤ b",
      "endPos": {"line": 12, "column": 18}},
     {"tactic": "exact div_le_of_le_mul h",
      "proofState": 1,
      "pos": {"line": 13, "column": 2},
      "goals": "a b c : â„â‰¥0âˆ h : a â‰¤ b / c âŠ¢ a * câ»Â¹â»Â¹ â‰¤ b",
      "endPos": {"line": 13, "column": 26}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 84
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_le_iff_inv_le : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a := by
     simpa only [inv_inv] using @ENNReal.inv_le_inv a bâ»Â¹

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simpa only [inv_inv] using @ENNReal.inv_le_inv a bâ»Â¹",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a",
      "endPos": {"line": 12, "column": 54}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 85
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_two_add_inv_two : (2 : â„â‰¥0âˆ)â»Â¹ + 2â»Â¹ = 1 := by
     rw [â† two_mul, â† div_eq_mul_inv, ENNReal.div_self two_ne_zero two_ne_top]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "rw [â† two_mul, â† div_eq_mul_inv, ENNReal.div_self two_ne_zero two_ne_top]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "âŠ¢ 2â»Â¹ + 2â»Â¹ = 1",
      "endPos": {"line": 12, "column": 75}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 86
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem NumberField.ComplexEmbedding.IsReal.comp (f : k â†’+* K) {Ï† : K â†’+* â„‚} (hÏ† : IsReal Ï†) :
       IsReal (Ï†.comp f) := by
     ext1 x; simpa using RingHom.congr_fun hÏ† (f x)

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:57: unexpected token '+'; expected term
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 87
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.mul_div_mul_left (a b : â„â‰¥0âˆ) (hc : c â‰  0) (hc' : c â‰  âŠ¤) :
       c * a / (c * b) = a / b := by
     rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inl hc) (Or.inl hc'), mul_mul_mul_comm,
       ENNReal.mul_inv_cancel hc hc', one_mul]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inl hc) (Or.inl hc'), mul_mul_mul_comm,\n  ENNReal.mul_inv_cancel hc hc', one_mul]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "c a b : â„â‰¥0âˆ hc : c â‰  0 hc' : c â‰  âŠ¤ âŠ¢ c * a / (c * b) = a / b",
      "endPos": {"line": 14, "column": 43}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 88
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_ne_zero : a / b â‰  0 â†” a â‰  0 âˆ§ b â‰  âŠ¤ := by
     rw [â† pos_iff_ne_zero, div_pos_iff]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [â† pos_iff_ne_zero, div_pos_iff]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ a / b â‰  0 â†” a â‰  0 âˆ§ b â‰  âŠ¤",
      "endPos": {"line": 12, "column": 37}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 89
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_eq_zero_iff : a / b = 0 â†” a = 0 âˆ¨ b = âˆ := by
     simp [div_eq_mul_inv]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [div_eq_mul_inv]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ a / b = 0 â†” a = 0 âˆ¨ b = âŠ¤",
      "endPos": {"line": 12, "column": 23}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 90
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.div_eq_top : a / b = âˆ â†” a â‰  0 âˆ§ b = 0 âˆ¨ a = âˆ âˆ§ b â‰  âˆ := by
     simp [div_eq_mul_inv, ENNReal.mul_eq_top]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp [div_eq_mul_inv, ENNReal.mul_eq_top]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a b : â„â‰¥0âˆ âŠ¢ a / b = âŠ¤ â†” a â‰  0 âˆ§ b = 0 âˆ¨ a = âŠ¤ âˆ§ b â‰  âŠ¤",
      "endPos": {"line": 12, "column": 43}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 91
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem NumberField.InfinitePlace.norm_embedding_eq (w : InfinitePlace K) (x : K) :
       â€–(embedding w) xâ€– = w x := by
     nth_rewrite 2 [â† mk_embedding w]
     rfl

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:7:4: expected token
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ“] row 92
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.inv_le_iff_le_mul (hâ‚ : b = âˆ â†’ a â‰  0) (hâ‚‚ : a = âˆ â†’ b â‰  0) : aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b := by
     rw [â† one_div, ENNReal.div_le_iff_le_mul, mul_comm]
     exacts [or_not_of_imp hâ‚, not_or_of_imp hâ‚‚]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [â† one_div, ENNReal.div_le_iff_le_mul, mul_comm]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals":
      "a b : â„â‰¥0âˆ hâ‚ : b = âŠ¤ â†’ a â‰  0 hâ‚‚ : a = âŠ¤ â†’ b â‰  0 âŠ¢ aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b",
      "endPos": {"line": 12, "column": 53}},
     {"tactic": "exacts [or_not_of_imp hâ‚, not_or_of_imp hâ‚‚]",
      "proofState": 1,
      "pos": {"line": 13, "column": 2},
      "goals":
      "case hb0\na b : â„â‰¥0âˆ\nhâ‚ : b = âŠ¤ â†’ a â‰  0\nhâ‚‚ : a = âŠ¤ â†’ b â‰  0\nâŠ¢ a â‰  0 âˆ¨ b â‰  âŠ¤\ncase hbt a b : â„â‰¥0âˆ hâ‚ : b = âŠ¤ â†’ a â‰  0 hâ‚‚ : a = âŠ¤ â†’ b â‰  0 âŠ¢ a â‰  âŠ¤ âˆ¨ b â‰  0",
      "endPos": {"line": 13, "column": 45}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 93
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.ENNReal.Operations
   import Mathlib.Data.ENNReal.Inv

   namespace myNameSpace


   open ENNReal
   open Set NNReal
   variable {a b c d : â„â‰¥0âˆ} {r p q : â„â‰¥0}

   theorem ENNReal.add_halves (a : â„â‰¥0âˆ) : a / 2 + a / 2 = a := by
     rw [div_eq_mul_inv, â† mul_add, inv_two_add_inv_two, mul_one]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [div_eq_mul_inv, â† mul_add, inv_two_add_inv_two, mul_one]",
      "proofState": 0,
      "pos": {"line": 12, "column": 2},
      "goals": "a : â„â‰¥0âˆ âŠ¢ a / 2 + a / 2 = a",
      "endPos": {"line": 12, "column": 62}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ—] row 94
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem NumberField.InfinitePlace.not_isReal_of_mk_isComplex {Ï† : K â†’+* â„‚} (h : IsComplex (mk Ï†)) :
       Â¬ ComplexEmbedding.IsReal Ï† := by
     rwa [â† isComplex_mk_iff]

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:69: unexpected token '+'; expected term
     error: Lean exited with code 1
     Some required builds logged failures:
     - TmpProjDir.Basic
     error: build failed



   ================================================================================
[âœ—] row 95
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   namespace myNameSpace

   Unable to analyze

   theorem NumberField.InfinitePlace.isReal_or_isComplex (w : InfinitePlace K) : IsReal w âˆ¨ IsComplex w := by
     rw [â† not_isReal_iff_isComplex]; exact em _

   end myNameSpace
   ----------------------------------------
   â€£ error: âœ– [11/13] Building TmpProjDir.Basic
     trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/REPL/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/jprthwsh/.elan/toolchains/leanprover--lean4---v4.11.0/bin/lean ././././TmpProjDir/Basic.lean -R ./././. -o ././.lake/build/lib/TmpProjDir/Basic.olean -i ././.lake/build/lib/TmpProjDir/Basic.ilean -c ././.lake/build/ir/TmpProjDir/Basic.c --json
     error: ././././TmpProjDir/Basic.lean:4:0: unexpected identifier; expected command
     error: ././././TmpProjDir/Basic.lean:6:59: function expected at
       InfinitePlace
     term has type
       ?m.3
     error: ././././TmpProjDir/Basic.lean:6:78: function expected at
       IsReal
     term has type
       ?m.10
     error: ././././TmpProjDir/Basic.lean:6:89: function expected at



   ================================================================================
[âœ“] row 96
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Order.Filter.Cofinite
   import Mathlib.Topology.Bornology.Basic

   namespace myNameSpace


   open Bornology
   open Set Filter
   variable {Î¹ Î± Î² : Type*}
   variable {_ : Bornology Î±} {s t : Set Î±} {x : Î±}

   theorem Bornology.nonempty_of_not_isBounded (h : Â¬IsBounded s) : s.Nonempty := by
     rw [nonempty_iff_ne_empty]
     rintro rfl
     exact h isBounded_empty

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [nonempty_iff_ne_empty]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_2 xâœ : Bornology Î± s : Set Î± h : Â¬IsBounded s âŠ¢ s.Nonempty",
      "endPos": {"line": 13, "column": 28}},
     {"tactic": "rintro rfl",
      "proofState": 1,
      "pos": {"line": 14, "column": 2},
      "goals": "Î± : Type u_2 xâœ : Bornology Î± s : Set Î± h : Â¬IsBounded s âŠ¢ s â‰  âˆ…",
      "endPos": {"line": 14, "column": 12}},
     {"tactic": "exact h isBounded_empty",
      "proofState": 2,
      "pos": {"line": 15, "column": 2},
      "goals": "Î± : Type u_2 xâœ : Bornology Î± h : Â¬IsBounded âˆ… âŠ¢ False",
      "endPos": {"line": 15, "column": 25}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 97
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Order.Filter.Cofinite
   import Mathlib.Topology.Bornology.Basic

   namespace myNameSpace


   open Bornology
   open Set Filter
   variable {Î¹ Î± Î² : Type*}
   variable {_ : Bornology Î±} {s t : Set Î±} {x : Î±}

   theorem Bornology.isBounded_union : IsBounded (s âˆª t) â†” IsBounded s âˆ§ IsBounded t := by
     simp only [â† isCobounded_compl_iff, compl_union, isCobounded_inter]

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic":
      "simp only [â† isCobounded_compl_iff, compl_union, isCobounded_inter]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals":
      "Î± : Type u_2 xâœ : Bornology Î± s t : Set Î± âŠ¢ IsBounded (s âˆª t) â†” IsBounded s âˆ§ IsBounded t",
      "endPos": {"line": 13, "column": 69}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 98
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Order.Filter.Cofinite
   import Mathlib.Topology.Bornology.Basic

   namespace myNameSpace


   open Bornology
   open Set Filter
   variable {Î¹ Î± Î² : Type*}
   variable {_ : Bornology Î±} {s t : Set Î±} {x : Î±}

   theorem Bornology.isBounded_empty : IsBounded (âˆ… : Set Î±) := by
     rw [isBounded_def, compl_empty]
     exact univ_mem

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "rw [isBounded_def, compl_empty]",
      "proofState": 0,
      "pos": {"line": 13, "column": 2},
      "goals": "Î± : Type u_2 xâœ : Bornology Î± âŠ¢ IsBounded âˆ…",
      "endPos": {"line": 13, "column": 33}},
     {"tactic": "exact univ_mem",
      "proofState": 1,
      "pos": {"line": 14, "column": 2},
      "goals": "Î± : Type u_2 xâœ : Bornology Î± âŠ¢ univ âˆˆ cobounded Î±",
      "endPos": {"line": 14, "column": 16}}],
    "env": 0}
   ----------------------------------------



   ================================================================================
[âœ“] row 99
   ----------------------------------------
   >> Lean source:
   ----------------------------------------
   import Mathlib.Data.Finset.Lattice
   import Mathlib.Data.Set.Finite
   import Mathlib.Order.Closure
   import Mathlib.Order.UpperLower.Basic
   import Mathlib.Order.SupClosed

   namespace myNameSpace



   variable {F Î± Î² : Type*}
   variable [SemilatticeSup Î±] [SemilatticeSup Î²]
   variable {Î¹ : Sort*} {S : Set (Set Î±)} {f : Î¹ â†’ Set Î±} {s t : Set Î±} {a : Î±}
   open Set
   open Set
   variable {Î¹ : Type*} {f : Î¹ â†’ Î±} {s : Set Î±} {t : Finset Î¹} {a : Î±}
   open Finset
   open Finset
   variable [SemilatticeInf Î±] [SemilatticeInf Î²]
   variable {Î¹ : Sort*} {S : Set (Set Î±)} {f : Î¹ â†’ Set Î±} {s t : Set Î±} {a : Î±}
   open Set
   open Set
   variable {Î¹ : Type*} {f : Î¹ â†’ Î±} {s : Set Î±} {t : Finset Î¹} {a : Î±}
   open Finset
   open Finset
   open Finset OrderDual
   variable {Î¹ : Sort*} [Lattice Î±] [Lattice Î²] {S : Set (Set Î±)} {f : Î¹ â†’ Set Î±} {s t : Set Î±} {a : Î±}
   open Set
   variable [LinearOrder Î±]
   open Finset
   variable [SemilatticeSup Î±] [SemilatticeSup Î²] {s t : Set Î±} {a b : Î±}
   variable [SemilatticeInf Î±] [SemilatticeInf Î²] {s t : Set Î±} {a b : Î±}
   variable [Lattice Î±] {s t : Set Î±}

   theorem latticeClosure_empty : latticeClosure (âˆ… : Set Î±) = âˆ… := by
     simp

   end myNameSpace
   ----------------------------------------
   >> REPL ran successfully!
   ----------------------------------------
   {"tactics":
    [{"tactic": "simp",
      "proofState": 0,
      "pos": {"line": 36, "column": 2},
      "goals":
      "Î± : Type u_2\ninstâœâ¶ : SemilatticeSup Î±\ninstâœâµ : SemilatticeInf Î±\ninstâœâ´ : Lattice Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : SemilatticeSup Î±\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : Lattice Î±\nâŠ¢ latticeClosure âˆ… = âˆ…",
      "endPos": {"line": 36, "column": 6}}],
    "messages":
    [{"severity": "warning",
      "pos": {"line": 35, "column": 0},
      "endPos": {"line": 36, "column": 6},
      "data":
      "automatically included section variable(s) unused in theorem 'myNameSpace.latticeClosure_empty':\n  [SemilatticeSup Î±]\n  [SemilatticeInf Î±]\n  [Lattice Î±]\n  [LinearOrder Î±]\n  [SemilatticeSup Î±]\n  [SemilatticeInf Î±]\nconsider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:\n  omit [SemilatticeSup\n  Î±] [SemilatticeInf Î±] [Lattice Î±] [LinearOrder Î±] [SemilatticeSup Î±] [SemilatticeInf Î±] in theorem ...\nnote: this linter can be disabled with `set_option linter.unusedSectionVars false`"}],
    "env": 0}
   ----------------------------------------

*** Compiled 80/100 successfully.

*** Computed DAG for 80/100 successfully.
Saved results to herald_lean_dag.csv
